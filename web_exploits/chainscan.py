import os
import subprocess
import sys
import collections
import requests
import asyncio
import aiohttp
import re
from tqdm import tqdm
import time

class ChainScan:

    def __init__(self,args):
        self.host = args[1]
        self.args = args
        self.ports = {}
        self.http_ports = {'http':[],'https':[]}
        self.urls = []
        self.nmapped = True
        #execute inputted commands

        #nmap is always first option
        self.nmap()
        for i in range(2,len(args)):
            f = 'self.{}()'.format(args[i]) 
            eval(f)
        

    def nmap(self):
        start = input('Start NMAP? [y]/[n]')
        
        if start == 'y':
            #current directory
            command = subprocess.run('pwd', shell=True, check=True, text=True)

            #run nmap command
            command = subprocess.run('nmap -T4 -Pn -oN nmap.txt {}'.format(self.host), shell=True, check=True, text=True)
            
            #grep for all open ports and make it into a readable dictionary
            string_output = subprocess.check_output("cat nmap.txt | grep open", shell=True, universal_newlines=True)
            #print(output)
            results = string_output.split('\n')
            services_dict = collections.defaultdict(list)
            #store results in a dictionary
            for i in range(len(results)-1):
                port, status, service = results[i].split()
                services_dict[service].append((port.split('/')[0],status))
                if service[:5] == 'https':
                    self.http_ports['https'].append(port.split('/')[0])
                elif service[:4] == 'http':
                    self.http_ports['http'].append(port.split('/')[0])
            self.ports = services_dict
            print(self.ports)
        else:
            self.nmapped = False
            
    def nikto(self):
        start = input('Start NIKTO? [y]/[n]')
        if start == 'y':
            if not self.nmapped:
                print('nikto requires nmap first')
                start2 = input('Start nmap? [y][n]')
                if start2 == 'y':
                    self.nmap()
                else:
                    exit(0)
            for service in self.http_ports.keys():
                for port in self.http_ports[service]:
                    command = subprocess.run('nikto -host {} -port {}'.format(self.host,port), shell=True, check=True, text=True)

        else:
            exit(0)

    def dirbuster(self):
        #make url
        print("Starting Dir Scanner")

        if not self.nmapped:
            print('dirbuster requires nmap first')
            start2 = input('Start nmap? [y][n]')
            if start2 == 'y':
                self.nmap()
            else:
                exit(0)

        wordlist = input("Input Path of the wordlist (enter for default)")
        if not wordlist:
            wordlist = '/opt/dirbuster/directory-list-2.3-medium.txt'
        fo = open(wordlist,"r+")
        output = subprocess.check_output('wc -l {}'.format(wordlist) ,shell=True, universal_newlines=True)
        num_lines = int(output.split()[0])
        
        async def dirscan(url):
            async with aiohttp.ClientSession() as session:
                for i in tqdm(range(num_lines)):
                    word = fo.readline(10).strip()
                    complete_url = url + word +'/'
                    #print("Trying:" + complete_url)
                    async with session.get(complete_url) as resp:
                    #response = await requests.get(complete_url)
                        response = resp.status
                        if response == 200:
                            #print("Found:", response)
                            self.urls.append(complete_url)
                    

        for service in self.http_ports.keys():
            for port in self.http_ports[service]:
                url = '{}://{}:{}/'.format(service,self.host,port)
                cont = input('Would you like to continue with {} [y]/[n]?'.format(url))
                if cont == 'y':
                    asyncio.run(dirscan(url))
                else:
                    continue
        print("URLs Found:")
        print(self.urls)

    def curl(self):
        if len(self.urls) < 1:
            print("No URL Found")
            exit(0)

        for u in self.urls:
            try:
                command = subprocess.run('curl -kv {}'.format(u) ,shell=True, check=True, text=True)
                print('\n')
            except ValueError:
                print("Not a valid URL")
    
    def wfuzz(self):
        start = input('This web fuzz will enumerate all the subdomains. Start? [y][n]')
        #if self.host is an IP address
        if start == 'y':
            pattern = r'^((\d{1,3})\.){3}(\d{1,3})$'
            
            if re.match(pattern, self.host):
                print('Please input Domain name instead of IP and add a line in /etc/hosts, trying nslookup...')
                output = subprocess.check_output('nslookup {}'.format(self.host) ,shell=True, universal_newlines=True)
                
                domains = [line.split(' = ') for line in output.split('\n')]
                for dom in domains:
                    if len(dom) == 2:
                        print('Found domain name: {}'.format(dom[1]))
                print('Completed')
                #print(domains)
            else:
                wordlist = input('Provide path to a wordlist:')
                if not wordlist:
                    wordlist = '/usr/share/wfuzz/wordlist/general/medium.txt'
                for service in self.http_ports.keys():
                    for port in self.http_ports[service]:
                        process = subprocess.Popen('wfuzz -w {} -u "http://{}:{}/" -H "Host:FUZZ.{}" '.format(wordlist,self.host,port,self.host), shell=True, universal_newlines=True, stdout=subprocess.PIPE)
                        time.sleep(1)
                        process.terminate()
                        output, error = process.communicate()
                        #output_str = output.decode("utf-8")
                        lines = output.strip().split('\n')
                        count = {}
                        maxCount = ('',0)
                        for line in lines:

                            l = line.strip().split('\x1b[0m')
                            if len(l) > 6:
                                word_count = l[3].strip()
                                count[word_count] = 1 + count.get(word_count,0)
                                if count[word_count] > maxCount[1]:
                                    maxCount = (word_count,count[word_count])
                        print(count)
                        #TODO  make a while loop to run wfuzz untill we get unique subdomain word counts
                        #TODO  use --hw to remove the response with this word count
        else:
            exit(0)